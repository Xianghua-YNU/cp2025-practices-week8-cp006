# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

N	S_up		S_down		相对差异
------------------------------------------------------------
10	2.92896825	2.92896825	0.00000000e+00
100	5.18737752	5.18737752	1.71219160e-16
1000	7.48547086	7.48547086	3.55960942e-16
10000	9.78760604	9.78760604	3.81129905e-15


### 4.2 误差分析图
（在此插入相对差异δ随N变化的双对数图）
![image](https://github.com/user-attachments/assets/04f6b7f0-0c64-40c7-b04f-81b2648fbeb7)

## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   - （分析图表趋势）

 
当分析相对差异随  （假设   表示参与求和的数值个数）的变化趋势时，如果绘制了相关图表。通常随着   的增大，相对差异可能会呈现出不同的趋势。例如，如果求和使用的是简单的顺序求和方法，随着   的增加，相对差异可能会逐渐增大。这是因为随着参与求和的数值增多，每一步加法运算中的舍入误差不断累积，导致最终结果与准确值之间的相对差异越来越大。若采用了不同的求和策略（如从大到小求和），相对差异的增长速度可能会比简单顺序求和要慢，甚至在一定范围内相对差异保持相对稳定。通过观察图表中相对差异曲线的斜率和走向，可以直观地了解不同求和方法下相对差异随   的变化情况。

2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）
   - （结合浮点数表示方式解释）
 
为什么   更精确：假设   表示从大到小进行求和的结果。从大到小求和更精确的原因在于，当两个数相加时，如果两个数的量级差异较大，较小的数在与较大的数相加时，可能会因为浮点数的精度限制而被“吞没”。例如，在浮点数表示中，一个非常小的数加上一个很大的数，由于浮点数的尾数部分有限，小的数的有效数字可能无法被正确表示，从而导致舍入误差。而从大到小求和时，先将较大的数相加，它们的和在量级上相对稳定，后续加入较小的数时，对结果的影响相对较小，舍入误差的累积相对较少，所以结果更精确。
结合浮点数表示方式解释：浮点数通常由符号位、指数位和尾数位组成。在进行加法运算时，需要对两个数进行对阶操作，即将指数较小的数的尾数右移，使其指数与较大的数的指数相同。在右移过程中，可能会丢失一些尾数的低位信息，导致舍入误差。当从大到小求和时，对阶操作中较小数的尾数右移的位数相对较少，丢失的信息也较少，因此舍入误差相对较小。而从从小到大求和时，随着不断加入较小的数，对阶过程中尾数右移的位数可能会逐渐增多，丢失的信息也会增多，从而导致舍入误差不断累积。
### 5.2 误差来源分析
1. 浮点数表示精度限制
2. 加法运算中的舍入
3. 求和顺序的影响
浮点数表示精度限制：由于浮点数的尾数部分是有限的，它只能表示一定范围内的数值精度。例如，在单精度浮点数中，尾数通常有 23 位，这意味着它只能精确表示一定数量的有效数字。对于一些无限小数或非常大/小的数，在转换为浮点数表示时，可能会进行舍入操作，从而引入误差。
加法运算中的舍入：在每次加法运算中，当两个浮点数相加时，由于对阶和尾数运算的过程，可能会产生舍入误差。如前面所述，对阶时尾数的右移可能会丢失低位信息，而在尾数相加后，可能需要进行规格化操作，也可能会导致舍入。这些舍入误差会在每次加法运算中逐渐累积，影响最终的求和结果。
求和顺序的影响：不同的求和顺序会导致舍入误差的累积方式不同。如前面分析的，从小到大求和时，较小的数容易被较大的数“吞没”，导致舍入误差较大；而从大到小求和时，舍入误差相对较小。此外，不同的求和顺序还可能导致中间结果的量级变化不同，从而影响后续加法运算中的舍入误差。

## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）
通过实验发现，求和顺序对计算精度有着显著的影响。从大到小求和通常能够有效地减少舍入误差的累积，获得更精确的结果，这是因为它减少了较小数被较大数“吞没”的情况。而简单的从小到大求和或其他求和顺序可能会导致舍入误差快速累积，使结果与准确值之间的差异增大。浮点数表示精度限制、加法运算中的舍入以及求和顺序是导致计算误差的主要来源。在进行数值求和计算时，选择合适的求和顺序对于提高计算精度至关重要。
## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？

2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？

3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
为什么从大到小求和通常能获得更好的精度？：从大到小求和能获得更好精度的主要原因是减少了较小数在加法运算中被较大数“吞没”的情况。在浮点数运算中，当两个数的量级差异较大时，较小数的有效数字可能无法在加法运算中被正确表示。从大到小求和时，先处理较大的数，它们的和在量级上相对稳定，后续加入较小的数时，对结果的影响相对较小，从而减少了舍入误差的累积。
在实际应用中，如何选择合适的求和策略来减小舍入误差？：在实际应用中，可以先对参与求和的数值进行排序，根据数值的大小选择从大到小的求和顺序。如果数据量较大，可以考虑采用分组求和的方法，将数据分成若干组，分别对每组数据进行求和，然后再将组的和相加，这样可以在一定程度上减少舍入误差的累积。还可以使用更高精度的浮点数表示（如双精度浮点数），以提高数值表示的精度，减少舍入误差。
除了改变求和顺序，还有什么方法可以提高数值计算的精度？：除了改变求和顺序，还可以使用多精度计算库，这些库可以提供比标准浮点数类型更高的精度，能够更准确地表示数值和进行运算。可以采用误差补偿算法，如 Kahan 求和算法，它通过记录每次加法运算中的误差，并在后续运算中进行补偿，从而减少舍入误差的累积。在进行数值计算前，对数据进行预处理，如对数据进行归一化或缩放，使数据的量级在一个合适的范围内，也可以减少舍入误差的影响。
## 附录：关键代码
import numpy as np
import matplotlib.pyplot as plt


def sum_up(N):
    """从小到大计算调和级数和"""
    result = 0.0
    for n in range(1, N + 1):
        result += 1.0 / n
    return result


def sum_down(N):
    """从大到小计算调和级数和"""
    result = 0.0
    for n in range(N, 0, -1):
        result += 1.0 / n
    return result


def calculate_relative_difference(N):
    """计算两种方法的相对差异"""
    s_up = sum_up(N)
    s_down = sum_down(N)
    return abs(s_up - s_down) / abs((s_up + s_down) / 2.0)


def plot_differences():
    """绘制相对差异随N的变化"""
    N_values = np.logspace(1, 4, 50, dtype=int)
    differences = [calculate_relative_difference(N) for N in N_values]

    plt.figure(figsize=(10, 6))
    plt.loglog(N_values, differences, 'o-', alpha=0.7)

    plt.grid(True, which="both", ls="-", alpha=0.2)
    plt.xlabel('N')
    plt.ylabel('Relative Difference')
    plt.title('Relative Difference vs N')

    plt.savefig('harmonic_sum_differences.png', dpi=300, bbox_inches='tight')
    plt.show()


def print_results():
    """打印典型N值的计算结果"""
    N_values = [10, 100, 1000, 10000]

    print("\n计算结果:")
    print("N\tS_up\t\tS_down\t\t相对差异")
    print("-" * 60)

    for N in N_values:
        s_up = sum_up(N)
        s_down = sum_down(N)
        diff = calculate_relative_difference(N)
        print(f"{N}\t{s_up:.8f}\t{s_down:.8f}\t{diff:.8e}")


def main():
    """主函数"""
    # 打印计算结果
    print_results()

    # 绘制误差图
    plot_differences()


if __name__ == "__main__":
    main()
